<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ancient Battle Simulator</title>
  <style>
    :root {
      --bg: #12100d;
      --panel: #1f1a16;
      --panel-soft: #2a241d;
      --ink: #f2e9d8;
      --accent: #f0b96b;
      --danger: #dc6f55;
      --ally: #7ac3ff;
      --enemy: #ff9f8e;
      --routed: #9f9f9f;
      --tile: #3a3228;
      --tile-alt: #352e25;
      --tile-deploy: #2f4633;
      --tile-enemy: #4a2f2f;
      --highlight: #f8e29a;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(circle at top, #2a2219, var(--bg));
      color: var(--ink);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .shell {
      width: min(1200px, 100%);
      background: rgba(20, 16, 12, 0.96);
      border: 1px solid #4e3e2b;
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
      display: grid;
      grid-template-columns: minmax(600px, 1fr) 320px;
      gap: 14px;
    }

    .battlefield-wrap {
      display: grid;
      gap: 10px;
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      background: var(--panel);
      padding: 10px 12px;
      border: 1px solid #473826;
      border-radius: 10px;
      font-size: 14px;
    }

    #battlefield {
      display: grid;
      grid-template-columns: repeat(14, 1fr);
      gap: 2px;
      background: #3c3228;
      border: 1px solid #5a4a35;
      border-radius: 8px;
      overflow: hidden;
      aspect-ratio: 14 / 10;
      user-select: none;
    }

    .tile {
      position: relative;
      background: var(--tile);
      border: 1px solid #2d261f;
      display: grid;
      place-items: center;
      font-size: 11px;
      cursor: pointer;
      transition: filter .12s ease;
    }

    .tile:nth-child(even) { background: var(--tile-alt); }
    .tile.deploy { background: var(--tile-deploy); }
    .tile.enemy-zone { background: var(--tile-enemy); }
    .tile.move-target { outline: 2px solid #6ed489; outline-offset: -2px; }
    .tile.attack-target { outline: 2px solid var(--danger); outline-offset: -2px; }
    .tile.selected { outline: 2px solid var(--highlight); outline-offset: -2px; filter: brightness(1.2); }
    .tile:hover { filter: brightness(1.14); }

    .unit {
      width: 90%;
      height: 90%;
      border-radius: 7px;
      border: 1px solid rgba(0, 0, 0, 0.6);
      display: grid;
      grid-template-rows: auto auto;
      align-content: center;
      justify-items: center;
      line-height: 1.1;
      font-size: 10px;
      text-align: center;
      padding: 1px;
    }

    .unit.player { background: linear-gradient(145deg, #3a71a4, #20415c); color: #e8f6ff; }
    .unit.ai { background: linear-gradient(145deg, #a45545, #5f2c2c); color: #ffeceb; }
    .unit.routed { background: linear-gradient(145deg, #6b6b6b, #464646); color: #f0f0f0; }

    .side-panel {
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 10px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid #473826;
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.35;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      color: var(--accent);
    }

    h2 {
      margin: 0 0 6px;
      font-size: 14px;
      color: #f5c98d;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    button {
      border: 1px solid #6b5438;
      background: var(--panel-soft);
      color: var(--ink);
      border-radius: 8px;
      padding: 8px 10px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover { filter: brightness(1.1); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .log {
      max-height: 250px;
      overflow: auto;
      display: grid;
      gap: 5px;
    }

    .log p {
      margin: 0;
      padding: 5px;
      background: #2c251d;
      border-radius: 6px;
      border-left: 3px solid #6e5940;
      font-size: 12px;
    }

    .hint {
      color: #dbccb8;
      font-size: 12px;
      margin-top: 6px;
    }

    .pill {
      border-radius: 999px;
      border: 1px solid #7f6648;
      background: #322a21;
      padding: 2px 8px;
      margin-right: 4px;
      font-size: 11px;
    }

    @media (max-width: 1040px) {
      .shell { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="battlefield-wrap">
      <div class="topbar">
        <div><strong>Player:</strong> <span id="playerGeneral"></span> (<span id="playerFaction"></span>)</div>
        <div><strong>Enemy:</strong> <span id="aiGeneral"></span> (<span id="aiFaction"></span>)</div>
        <div><span class="pill" id="phaseText"></span> <span class="pill" id="turnText"></span></div>
      </div>
      <div id="battlefield" aria-label="battlefield"></div>
    </section>

    <aside class="side-panel">
      <section class="panel">
        <h1>Ancient Battle Simulator</h1>
        <div id="statusText">Deploy your host on the left half, then begin battle.</div>
        <div class="controls">
          <button id="nextBtn">End Turn</button>
          <button id="retreatBtn">Feigned Retreat</button>
          <button id="newBtn">New Battle</button>
        </div>
        <div class="hint">In deployment phase, click empty green tiles to place units. During battle, click your unit then a highlighted tile to move or attack.</div>
      </section>

      <section class="panel" id="unitPanel">
        <h2>Selected Unit</h2>
        <div id="unitDetails">No unit selected.</div>
      </section>

      <section class="panel">
        <h2>Army State</h2>
        <div id="armyStats"></div>
      </section>

      <section class="panel">
        <h2>Battle Log</h2>
        <div class="log" id="battleLog"></div>
      </section>
    </aside>
  </main>

  <script>
    const WIDTH = 14;
    const HEIGHT = 10;
    const UNIT_COUNT = 12;

    const GENERAL_POOL = [
      { name: "Hannibal Barca", faction: "Carthage", bonus: "flank" },
      { name: "Julius Caesar", faction: "Rome", bonus: "discipline" },
      { name: "Cleopatra VII", faction: "Egypt", bonus: "morale" },
      { name: "Sun Tzu", faction: "Wu", bonus: "trickery" },
      { name: "Leonidas", faction: "Sparta", bonus: "infantry" },
      { name: "Boudica", faction: "Iceni", bonus: "charge" },
      { name: "Alexander", faction: "Macedon", bonus: "cavalry" }
    ];

    const UNIT_TEMPLATES = [
      { type: "Spear", hp: 26, atk: 8, move: 2, morale: 78 },
      { type: "Sword", hp: 24, atk: 10, move: 2, morale: 74 },
      { type: "Archer", hp: 18, atk: 7, move: 2, morale: 64, range: 2 },
      { type: "Cavalry", hp: 22, atk: 9, move: 3, morale: 72 },
      { type: "Guard", hp: 30, atk: 9, move: 1, morale: 88 },
      { type: "Skirmisher", hp: 17, atk: 6, move: 3, morale: 61 }
    ];

    const battlefield = document.getElementById("battlefield");
    const playerGeneralEl = document.getElementById("playerGeneral");
    const playerFactionEl = document.getElementById("playerFaction");
    const aiGeneralEl = document.getElementById("aiGeneral");
    const aiFactionEl = document.getElementById("aiFaction");
    const phaseTextEl = document.getElementById("phaseText");
    const turnTextEl = document.getElementById("turnText");
    const statusTextEl = document.getElementById("statusText");
    const unitDetailsEl = document.getElementById("unitDetails");
    const armyStatsEl = document.getElementById("armyStats");
    const battleLogEl = document.getElementById("battleLog");

    const nextBtn = document.getElementById("nextBtn");
    const retreatBtn = document.getElementById("retreatBtn");
    const newBtn = document.getElementById("newBtn");

    const state = {
      grid: [],
      phase: "deploy",
      turn: "player",
      turnNumber: 1,
      selectedUnitId: null,
      playerGeneral: null,
      aiGeneral: null,
      playerUnits: [],
      aiUnits: [],
      toDeploy: [],
      retreatCooldown: 0,
      actionPoints: 0,
      maxActions: 0,
      gameOver: false
    };

    function rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function coordsToIndex(x, y) {
      return y * WIDTH + x;
    }

    function tileAt(x, y) {
      if (x < 0 || y < 0 || x >= WIDTH || y >= HEIGHT) return null;
      return state.grid[coordsToIndex(x, y)];
    }

    function createUnit(side, template, idx) {
      return {
        id: `${side}-${idx}-${Math.random().toString(36).slice(2, 7)}`,
        side,
        type: template.type,
        hp: template.hp,
        maxHp: template.hp,
        atk: template.atk,
        move: template.move,
        morale: template.morale,
        maxMorale: template.morale,
        range: template.range || 1,
        x: null,
        y: null,
        acted: false,
        routed: false
      };
    }

    function setupBattle() {
      state.grid = Array.from({ length: WIDTH * HEIGHT }, (_, i) => ({
        x: i % WIDTH,
        y: Math.floor(i / WIDTH),
        unitId: null
      }));
      state.phase = "deploy";
      state.turn = "player";
      state.turnNumber = 1;
      state.selectedUnitId = null;
      state.gameOver = false;

      const generals = shuffle([...GENERAL_POOL]);
      state.playerGeneral = generals[0];
      state.aiGeneral = generals[1];

      state.playerUnits = Array.from({ length: UNIT_COUNT }, (_, i) => createUnit("player", UNIT_TEMPLATES[i % UNIT_TEMPLATES.length], i));
      state.aiUnits = Array.from({ length: UNIT_COUNT }, (_, i) => createUnit("ai", UNIT_TEMPLATES[(i + 2) % UNIT_TEMPLATES.length], i));
      state.toDeploy = [...state.playerUnits];
      state.retreatCooldown = 0;

      autoDeployAI();
      state.maxActions = aliveUnits("player").length;
      state.actionPoints = state.maxActions;

      log(`A new clash begins: ${state.playerGeneral.name} vs ${state.aiGeneral.name}.`);
      updateHeader();
      render();
      setStatus("Deploy your units in green tiles on the left half.");
    }

    function autoDeployAI() {
      const candidates = [];
      for (let y = 0; y < HEIGHT; y++) {
        for (let x = 9; x < WIDTH; x++) candidates.push({ x, y });
      }
      shuffle(candidates);
      state.aiUnits.forEach((unit, i) => placeUnit(unit, candidates[i].x, candidates[i].y));
    }

    function placeUnit(unit, x, y) {
      const tile = tileAt(x, y);
      if (!tile || tile.unitId) return false;
      unit.x = x;
      unit.y = y;
      tile.unitId = unit.id;
      return true;
    }

    function removeUnitFromGrid(unit) {
      if (unit.x == null || unit.y == null) return;
      const tile = tileAt(unit.x, unit.y);
      if (tile && tile.unitId === unit.id) tile.unitId = null;
      unit.x = null;
      unit.y = null;
    }

    function getUnitById(id) {
      return [...state.playerUnits, ...state.aiUnits].find(u => u.id === id) || null;
    }

    function aliveUnits(side) {
      const list = side === "player" ? state.playerUnits : state.aiUnits;
      return list.filter(u => u.hp > 0);
    }

    function activeUnits(side) {
      return aliveUnits(side).filter(u => !u.routed);
    }

    function adjacentTiles(x, y) {
      return [
        { x: x + 1, y },
        { x: x - 1, y },
        { x, y: y + 1 },
        { x, y: y - 1 }
      ].map(c => tileAt(c.x, c.y)).filter(Boolean);
    }

    function distance(a, b) {
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }

    function movementOptions(unit) {
      const options = [];
      const frontier = [{ x: unit.x, y: unit.y, cost: 0 }];
      const seen = new Set([`${unit.x},${unit.y}`]);

      while (frontier.length) {
        const cur = frontier.shift();
        adjacentTiles(cur.x, cur.y).forEach(t => {
          const key = `${t.x},${t.y}`;
          const nCost = cur.cost + 1;
          if (seen.has(key) || nCost > unit.move) return;
          seen.add(key);
          if (!t.unitId) {
            options.push({ x: t.x, y: t.y });
            frontier.push({ x: t.x, y: t.y, cost: nCost });
          }
        });
      }
      return options;
    }

    function attackOptions(unit) {
      return (unit.side === "player" ? state.aiUnits : state.playerUnits)
        .filter(e => e.hp > 0)
        .filter(e => distance(unit, e) <= unit.range);
    }

    function calculateSurroundPenalty(unit) {
      const enemies = adjacentTiles(unit.x, unit.y)
        .map(t => getUnitById(t.unitId))
        .filter(Boolean)
        .filter(u => u.side !== unit.side && u.hp > 0 && !u.routed).length;
      return enemies >= 2 ? enemies * 3 : 0;
    }

    function computeArmyMorale(side) {
      const units = aliveUnits(side);
      if (!units.length) return 0;
      return Math.round(units.reduce((sum, u) => sum + Math.max(u.morale, 0), 0) / units.length);
    }

    function attack(attacker, defender) {
      const base = attacker.atk + rand(-2, 3);
      const flankBonus = calculateSurroundPenalty(defender);
      const commanderBoost = attacker.side === "player" && state.playerGeneral.bonus === "charge" ? 2 : 0;
      const damage = Math.max(2, base + Math.floor(flankBonus / 2) + commanderBoost);

      defender.hp -= damage;
      defender.morale -= rand(7, 14) + flankBonus;
      attacker.morale = Math.min(attacker.maxMorale, attacker.morale + 2);

      if (defender.hp <= 0) {
        defender.hp = 0;
        defender.morale = 0;
        removeUnitFromGrid(defender);
        log(`${attacker.type} destroys ${defender.type}.`);
      } else {
        const routedCheck = defender.morale < 25 || (defender.hp < defender.maxHp * 0.35 && Math.random() < 0.42);
        if (routedCheck) {
          defender.routed = true;
          defender.morale = Math.max(8, defender.morale);
          log(`${defender.type} routs under pressure!`);
        }
      }

      attacker.acted = true;
      state.actionPoints = Math.max(0, state.actionPoints - 1);
      evaluateSurrender();
    }

    function moveUnit(unit, x, y) {
      const from = tileAt(unit.x, unit.y);
      const to = tileAt(x, y);
      if (!to || to.unitId) return;
      from.unitId = null;
      to.unitId = unit.id;
      unit.x = x;
      unit.y = y;
      unit.acted = true;
      state.actionPoints = Math.max(0, state.actionPoints - 1);
    }

    function evaluateSurrender() {
      const playerAlive = aliveUnits("player").length;
      const aiAlive = aliveUnits("ai").length;
      const playerMorale = computeArmyMorale("player");
      const aiMorale = computeArmyMorale("ai");

      if (playerAlive === 0 || playerMorale < 12 || activeUnits("player").length < 3) {
        endGame("Defeat! Your army collapses and flees the field.");
      } else if (aiAlive === 0 || aiMorale < 12 || activeUnits("ai").length < 3) {
        endGame("Victory! The opposing host breaks and surrenders.");
      }
    }

    function endGame(message) {
      state.gameOver = true;
      setStatus(message);
      log(message);
      nextBtn.disabled = true;
      retreatBtn.disabled = true;
    }

    function setStatus(msg) {
      statusTextEl.textContent = msg;
    }

    function log(msg) {
      const p = document.createElement("p");
      p.textContent = `T${state.turnNumber}: ${msg}`;
      battleLogEl.prepend(p);
      while (battleLogEl.children.length > 26) battleLogEl.removeChild(battleLogEl.lastChild);
    }

    function updateHeader() {
      playerGeneralEl.textContent = state.playerGeneral.name;
      playerFactionEl.textContent = state.playerGeneral.faction;
      aiGeneralEl.textContent = state.aiGeneral.name;
      aiFactionEl.textContent = state.aiGeneral.faction;
      phaseTextEl.textContent = state.phase === "deploy" ? "Deployment" : "Battle";
      turnTextEl.textContent = `Turn ${state.turnNumber} 路 ${state.turn.toUpperCase()}`;
    }

    function selectionInfo(unit) {
      if (!unit) {
        unitDetailsEl.innerHTML = "No unit selected.";
        return;
      }
      unitDetailsEl.innerHTML = `<strong>${unit.type}</strong> (${unit.side})<br>HP ${unit.hp}/${unit.maxHp} 路 Morale ${Math.round(unit.morale)}<br>ATK ${unit.atk} 路 Move ${unit.move} 路 Range ${unit.range}${unit.routed ? "<br><em>Routed</em>" : ""}`;
    }

    function armyInfo() {
      const playerMorale = computeArmyMorale("player");
      const aiMorale = computeArmyMorale("ai");
      const playerAlive = aliveUnits("player").length;
      const aiAlive = aliveUnits("ai").length;
      armyStatsEl.innerHTML = `
        <div>Player units: <strong>${playerAlive}</strong> | Avg morale: <strong>${playerMorale}</strong></div>
        <div>Enemy units: <strong>${aiAlive}</strong> | Avg morale: <strong>${aiMorale}</strong></div>
        <div>Actions left this turn: <strong>${state.actionPoints}</strong></div>
        <div>Feigned retreat cooldown: <strong>${state.retreatCooldown}</strong></div>
      `;
    }

    function render() {
      battlefield.innerHTML = "";
      const selected = getUnitById(state.selectedUnitId);
      const moveTargets = selected && selected.side === "player" && state.turn === "player" && !selected.acted ? movementOptions(selected) : [];
      const attackTargets = selected && selected.side === "player" && state.turn === "player" && !selected.acted ? attackOptions(selected) : [];

      state.grid.forEach(tile => {
        const div = document.createElement("div");
        div.className = "tile";

        if (state.phase === "deploy") {
          if (tile.x <= 4) div.classList.add("deploy");
          if (tile.x >= 9) div.classList.add("enemy-zone");
        }

        if (selected && selected.x === tile.x && selected.y === tile.y) div.classList.add("selected");
        if (moveTargets.some(t => t.x === tile.x && t.y === tile.y)) div.classList.add("move-target");
        if (attackTargets.some(t => t.x === tile.x && t.y === tile.y)) div.classList.add("attack-target");

        const unit = getUnitById(tile.unitId);
        if (unit) {
          const unitDiv = document.createElement("div");
          const cls = unit.routed ? "routed" : unit.side;
          unitDiv.className = `unit ${cls}`;
          unitDiv.innerHTML = `<div>${unit.type}</div><div>${Math.max(0, unit.hp)} | ${Math.round(Math.max(0, unit.morale))}</div>`;
          div.appendChild(unitDiv);
        }

        div.addEventListener("click", () => onTileClick(tile.x, tile.y));
        battlefield.appendChild(div);
      });

      selectionInfo(selected);
      updateHeader();
      armyInfo();
    }

    function onTileClick(x, y) {
      if (state.gameOver) return;
      const tile = tileAt(x, y);
      const clickedUnit = getUnitById(tile.unitId);

      if (state.phase === "deploy") {
        if (state.toDeploy.length && x <= 4 && !tile.unitId) {
          const unit = state.toDeploy.shift();
          placeUnit(unit, x, y);
          log(`Deploy ${unit.type} at (${x},${y}).`);
          if (!state.toDeploy.length) {
            state.phase = "battle";
            setStatus("Battle joined! Select units to maneuver and attack.");
            log("Deployment complete. The horns of war sound.");
            resetTurn("player");
          }
        }
        render();
        return;
      }

      if (state.turn !== "player") return;

      const selected = getUnitById(state.selectedUnitId);

      if (clickedUnit && clickedUnit.side === "player") {
        state.selectedUnitId = clickedUnit.id;
        render();
        return;
      }

      if (!selected || selected.side !== "player" || selected.acted || selected.routed) return;

      const possibleMove = movementOptions(selected).find(t => t.x === x && t.y === y);
      if (possibleMove) {
        moveUnit(selected, x, y);
        log(`${selected.type} maneuvers to (${x},${y}).`);
        state.selectedUnitId = selected.id;
        evaluateSurrender();
        render();
        return;
      }

      if (clickedUnit && clickedUnit.side === "ai" && attackOptions(selected).some(e => e.id === clickedUnit.id)) {
        attack(selected, clickedUnit);
        log(`${selected.type} strikes ${clickedUnit.type} for heavy fighting.`);
        state.selectedUnitId = selected.id;
        render();
      }
    }

    function resetTurn(side) {
      state.turn = side;
      const units = side === "player" ? aliveUnits("player") : aliveUnits("ai");
      units.forEach(u => {
        u.acted = false;
        if (u.routed) {
          u.morale += rand(1, 5);
          if (u.morale > 42 && Math.random() < 0.45) {
            u.routed = false;
            log(`${u.type} rallies and rejoins the line.`);
          }
        }
        const surroundPenalty = calculateSurroundPenalty(u);
        if (surroundPenalty > 0) u.morale -= surroundPenalty;
      });

      state.maxActions = activeUnits(side).length;
      state.actionPoints = state.maxActions;
      if (side === "player") {
        if (state.retreatCooldown > 0) state.retreatCooldown -= 1;
      }

      evaluateSurrender();
      updateHeader();
      render();
    }

    function aiTurn() {
      if (state.gameOver) return;

      setStatus("Enemy is issuing orders...");
      const aiUnits = activeUnits("ai");

      aiUnits.forEach(unit => {
        if (unit.acted || state.gameOver) return;

        const attacks = attackOptions(unit).filter(target => !target.routed);
        if (attacks.length) {
          attacks.sort((a, b) => (a.hp + a.morale / 3) - (b.hp + b.morale / 3));
          attack(unit, attacks[0]);
          return;
        }

        const targets = activeUnits("player");
        if (!targets.length) return;
        targets.sort((a, b) => distance(unit, a) - distance(unit, b));
        const target = targets[0];

        const candidates = movementOptions(unit);
        candidates.sort((a, b) => distance(a, target) - distance(b, target));

        const best = candidates[0];
        if (best) {
          moveUnit(unit, best.x, best.y);
          if (Math.random() < 0.18) log(`${unit.type} feints toward your flank.`);
        }
      });

      setTimeout(() => {
        state.turnNumber += 1;
        resetTurn("player");
        if (!state.gameOver) setStatus("Your turn. Press the attack or reposition carefully.");
      }, 280);
    }

    function endPlayerTurn() {
      if (state.phase !== "battle" || state.gameOver || state.turn !== "player") return;
      state.turn = "ai";
      state.selectedUnitId = null;
      updateHeader();
      render();
      setTimeout(() => {
        resetTurn("ai");
        aiTurn();
      }, 180);
    }

    function feignedRetreat() {
      if (state.phase !== "battle" || state.turn !== "player" || state.retreatCooldown > 0 || state.gameOver) return;
      const selected = getUnitById(state.selectedUnitId);
      if (!selected || selected.side !== "player" || selected.type !== "Cavalry" || selected.acted) {
        setStatus("Select a fresh Cavalry unit to perform feigned retreat.");
        return;
      }

      const retreatX = Math.max(0, selected.x - 2);
      const tile = tileAt(retreatX, selected.y);
      if (!tile || tile.unitId) {
        setStatus("No room to retreat there.");
        return;
      }

      moveUnit(selected, retreatX, selected.y);
      selected.morale = Math.min(selected.maxMorale, selected.morale + 10);
      state.retreatCooldown = 4;
      log(`${selected.type} executes a feigned retreat, baiting pursuit.`);
      setStatus("Retreat executed. Enemy may overextend chasing you.");
      render();
    }

    nextBtn.addEventListener("click", endPlayerTurn);
    retreatBtn.addEventListener("click", feignedRetreat);
    newBtn.addEventListener("click", () => {
      battleLogEl.innerHTML = "";
      nextBtn.disabled = false;
      retreatBtn.disabled = false;
      setupBattle();
    });

    setupBattle();
  </script>
</body>
</html>
